<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Void Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        .ui-layer {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
            padding: 20px;
            pointer-events: none;
        }
        .ui-layer > * {
            pointer-events: auto;
        }
        .neon-text {
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            letter-spacing: 0.1em;
        }
        .hud {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 0;
            right: 0;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 30;
        }
        .btn-mobile {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            border-radius: 999px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            pointer-events: auto;
            min-width: 200px;
        }
        .btn-mobile:active {
            background: #0ff;
            color: #000;
        }
    </style>
</head>
<body>

    <div id="hud" class="hud hidden">
        <div class="flex flex-col">
            <div class="text-cyan-400 font-bold tracking-widest text-xs">SCORE</div>
            <div id="scoreEl" class="text-white text-xl font-black">0</div>
        </div>
        <div class="flex flex-col items-end">
            <div class="text-pink-500 font-bold tracking-widest text-xs">SHIELD</div>
            <div id="shieldEl" class="text-white text-xl font-black">100%</div>
        </div>
    </div>

    <div id="startScreen" class="ui-layer bg-black/90">
        <h1 class="text-5xl font-black mb-4 neon-text">NEON VOID</h1>
        <p class="text-cyan-300/70 mb-10 text-sm uppercase tracking-widest italic">Pilot the Void. Survive the Swarm.</p>
        <button id="startBtn" class="btn-mobile">Start Mission</button>
    </div>

    <div id="gameOverScreen" class="ui-layer bg-black/95 hidden">
        <h2 class="text-4xl font-bold mb-2 text-red-500">CRITICAL FAILURE</h2>
        <p class="text-white text-lg mb-8 uppercase tracking-widest">Score: <span id="finalScore" class="text-cyan-400 font-black">0</span></p>
        <button id="restartBtn" class="btn-mobile" style="border-color: #f43f5e; color: #f43f5e; box-shadow: 0 0 15px rgba(244, 63, 94, 0.3);">Reboot Ship</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playShoot() {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(400, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        g.gain.setValueAtTime(0.05, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + 0.1);
    },
    playExplosion() {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(100, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.3);
        g.gain.setValueAtTime(0.1, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + 0.3);
    },
    playPowerUp() {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.setValueAtTime(200, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.2);
        g.gain.setValueAtTime(0.1, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + 0.2);
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameW, gameH, playerObj, enemiesList, bulletsList, powerupsList, gameRunning = false, gameScore = 0;
let stars = [];
let gameTime = 0;
let lastFireTime = 0;

function initPlayer() {
    playerObj = { 
        x: gameW/2, y: gameH - 100, 
        size: 20, shield: 100, 
        targetX: gameW/2,
        powerup: null,
        powerupTimer: 0
    };
}

function initStars() {
    stars = [];
    for(let i = 0; i < 100; i++) {
        stars.push({
            x: Math.random() * gameW,
            y: Math.random() * gameH,
            s: Math.random() * 2 + 1,
            v: Math.random() * 3 + 1
        });
    }
}

function resize() {
    gameW = canvas.width = window.innerWidth;
    gameH = canvas.height = window.innerHeight;
    initStars();
    if(playerObj) {
        playerObj.y = gameH - 100;
        if (playerObj.x > gameW) playerObj.x = gameW - 20;
    }
}

window.addEventListener('resize', resize);
resize();

function handleMove(clientX) {
    if (playerObj) {
        playerObj.targetX = clientX;
    }
}

window.addEventListener('pointermove', (e) => handleMove(e.clientX));
window.addEventListener('pointerdown', (e) => handleMove(e.clientX));
canvas.addEventListener('touchstart', (e) => { if (gameRunning) e.preventDefault(); handleMove(e.touches[0].clientX); }, { passive: false });
canvas.addEventListener('touchmove', (e) => { if (gameRunning) e.preventDefault(); handleMove(e.touches[0].clientX); }, { passive: false });

function spawnEnemy() {
    const level = 1 + Math.floor(gameScore / 5000);
    const spawnRate = 0.02 + (level * 0.005);
    
    if (Math.random() < spawnRate) {
        const type = Math.random();
        let enemy = {
            x: Math.random() * gameW, y: -50,
            size: 15 + Math.random() * 10,
            speed: 2 + Math.random() * (2 + level * 0.5),
            hp: 1,
            color: '#f43f5e',
            type: 'basic',
            sin: 0
        };

        if (type > 0.8) {
            enemy.type = 'diver';
            enemy.speed *= 1.5;
            enemy.color = '#fbbf24';
        } else if (type > 0.6) {
            enemy.type = 'zigzag';
            enemy.color = '#a855f7';
        }

        enemiesList.push(enemy);
    }
}

function spawnPowerup(x, y) {
    if (Math.random() < 0.15) { // 15% chance on kill
        const types = ['multi', 'rapid', 'shield'];
        powerupsList.push({
            x, y,
            type: types[Math.floor(Math.random() * types.length)],
            vy: 2
        });
    }
}

function animate() {
    if (!gameRunning) return;
    gameTime++;
    
    // Background
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, gameW, gameH);
    
    // Stars
    ctx.fillStyle = '#ffffff';
    stars.forEach(s => {
        s.y += s.v;
        if (s.y > gameH) s.y = -10;
        ctx.globalAlpha = 0.5;
        ctx.fillRect(s.x, s.y, s.s, s.s);
    });
    ctx.globalAlpha = 1;

    // Player Movement
    playerObj.x += (playerObj.targetX - playerObj.x) * 0.25;
    playerObj.x = Math.max(20, Math.min(gameW - 20, playerObj.x));

    // Powerup Handling
    if (playerObj.powerupTimer > 0) playerObj.powerupTimer--;
    else playerObj.powerup = null;

    // Draw Player
    ctx.save();
    ctx.translate(playerObj.x, playerObj.y);
    const tilt = (playerObj.targetX - playerObj.x) * 0.05;
    ctx.rotate(Math.max(-0.5, Math.min(0.5, tilt)));
    
    ctx.shadowBlur = 15; ctx.shadowColor = '#0ff';
    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(15, 15);
    ctx.lineTo(-15, 15);
    ctx.closePath(); ctx.stroke();
    
    // Thruster flicker
    ctx.fillStyle = Math.random() > 0.5 ? '#0ff' : '#fff';
    ctx.fillRect(-5, 15, 10, 5 + Math.random() * 10);
    ctx.restore();

    // Shooting
    let fireDelay = playerObj.powerup === 'rapid' ? 80 : 150;
    if (Date.now() - lastFireTime > fireDelay) {
        if (playerObj.powerup === 'multi') {
            bulletsList.push({ x: playerObj.x, y: playerObj.y - 15, vx: -2 });
            bulletsList.push({ x: playerObj.x, y: playerObj.y - 15, vx: 0 });
            bulletsList.push({ x: playerObj.x, y: playerObj.y - 15, vx: 2 });
        } else {
            bulletsList.push({ x: playerObj.x, y: playerObj.y - 15, vx: 0 });
        }
        lastFireTime = Date.now();
        AudioSys.playShoot();
    }

    // Bullets
    bulletsList.forEach((b, i) => {
        b.y -= 12;
        b.x += b.vx || 0;
        ctx.fillStyle = playerObj.powerup ? '#0f0' : '#ff0';
        ctx.fillRect(b.x - 2, b.y, 4, 12);
        if (b.y < -20) bulletsList.splice(i, 1);
    });

    // Powerups
    powerupsList.forEach((p, i) => {
        p.y += p.vy;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = p.type === 'shield' ? '#ec4899' : '#10b981';
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(p.type[0].toUpperCase(), p.x, p.y + 4);

        if (Math.hypot(playerObj.x - p.x, playerObj.y - p.y) < 25) {
            if (p.type === 'shield') {
                playerObj.shield = Math.min(100, playerObj.shield + 30);
            } else {
                playerObj.powerup = p.type;
                playerObj.powerupTimer = 400;
            }
            powerupsList.splice(i, 1);
            AudioSys.playPowerUp();
        }
        if (p.y > gameH + 20) powerupsList.splice(i, 1);
    });

    // Enemies
    spawnEnemy();
    enemiesList.forEach((e, i) => {
        e.y += e.speed;
        if (e.type === 'zigzag') {
            e.sin += 0.1;
            e.x += Math.sin(e.sin) * 4;
        }
        
        ctx.shadowBlur = 5; ctx.shadowColor = e.color;
        ctx.strokeStyle = e.color; ctx.lineWidth = 2;
        ctx.strokeRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);

        bulletsList.forEach((b, bi) => {
            if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                spawnPowerup(e.x, e.y);
                enemiesList.splice(i, 1);
                bulletsList.splice(bi, 1);
                gameScore += 100;
                AudioSys.playExplosion();
            }
        });

        if (Math.hypot(playerObj.x - e.x, playerObj.y - e.y) < e.size + 15) {
            enemiesList.splice(i, 1);
            playerObj.shield -= 25;
            AudioSys.playExplosion();
            if (playerObj.shield <= 0) endGame();
        }

        if (e.y > gameH + 50) enemiesList.splice(i, 1);
    });

    document.getElementById('scoreEl').innerText = gameScore.toLocaleString();
    document.getElementById('shieldEl').innerText = playerObj.shield + '%';
    document.getElementById('shieldEl').style.color = playerObj.shield < 40 ? '#f43f5e' : 'white';
    
    requestAnimationFrame(animate);
}

function startGame() {
    AudioSys.init();
    gameScore = 0; gameTime = 0;
    enemiesList = []; bulletsList = []; powerupsList = [];
    initPlayer();
    gameRunning = true;
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    animate();
}

function endGame() {
    gameRunning = false;
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = gameScore.toLocaleString();
}

document.getElementById('startBtn').addEventListener('click', (e) => { e.stopPropagation(); startGame(); });
document.getElementById('restartBtn').addEventListener('click', (e) => { e.stopPropagation(); startGame(); });
</script>
</body>
</html>
