<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Void Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Critical: prevents browser gestures from stealing events */
        }
        .ui-layer {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
            padding: 20px;
            pointer-events: none; /* Allows clicks to pass through to the game when visible */
        }
        .ui-layer > * {
            pointer-events: auto; /* Re-enable for buttons */
        }
        .neon-text {
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            letter-spacing: 0.1em;
        }
        .hud {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 0;
            right: 0;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 30;
        }
        .btn-mobile {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            border-radius: 999px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            pointer-events: auto;
            min-width: 200px;
        }
        .btn-mobile:active {
            background: #0ff;
            color: #000;
        }
    </style>
</head>
<body>

    <div id="hud" class="hud hidden">
        <div class="text-cyan-400 font-bold">SCORE: <span id="scoreEl">0</span></div>
        <div class="text-pink-500 font-bold">SHIELD: <span id="shieldEl">100%</span></div>
    </div>

    <div id="startScreen" class="ui-layer bg-black/90">
        <h1 class="text-5xl font-black mb-4 neon-text">NEON VOID</h1>
        <p class="text-cyan-300/70 mb-10 text-sm uppercase tracking-widest">Hold & Drag to Pilot</p>
        <button id="startBtn" class="btn-mobile">Start Mission</button>
    </div>

    <div id="gameOverScreen" class="ui-layer bg-black/95 hidden">
        <h2 class="text-4xl font-bold mb-2 text-red-500">CRITICAL FAILURE</h2>
        <p class="text-white text-lg mb-8">SCORE: <span id="finalScore" class="text-cyan-400">0</span></p>
        <button id="restartBtn" class="btn-mobile" style="border-color: #f43f5e; color: #f43f5e; box-shadow: 0 0 15px rgba(244, 63, 94, 0.3);">Reboot Ship</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playShoot() {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(400, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        g.gain.setValueAtTime(0.05, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + 0.1);
    },
    playExplosion() {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(100, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.3);
        g.gain.setValueAtTime(0.1, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + 0.3);
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameW, gameH, playerObj, enemiesList, bulletsList, gameRunning = false, gameScore = 0;

function initPlayer() {
    playerObj = { x: gameW/2, y: gameH - 100, size: 20, shield: 100, targetX: gameW/2 };
}

function resize() {
    gameW = canvas.width = window.innerWidth;
    gameH = canvas.height = window.innerHeight;
    if(playerObj) {
        playerObj.y = gameH - 100;
        if (playerObj.x > gameW) playerObj.x = gameW - 20;
    }
}

window.addEventListener('resize', resize);
resize();

// Pointer Events are the modern way to handle both Mouse and Touch reliably
const handlePointer = (e) => {
    if (playerObj) {
        // Use clientX for viewport coordinates
        playerObj.targetX = e.clientX;
    }
};

// Use pointermove to handle mouse, touch, and stylus in one go
window.addEventListener('pointermove', handlePointer);
window.addEventListener('pointerdown', handlePointer);

// Still prevent default on touch to stop scrolling
window.addEventListener('touchstart', (e) => {
    if (gameRunning) e.preventDefault();
}, { passive: false });

window.addEventListener('touchmove', (e) => {
    if (gameRunning) e.preventDefault();
}, { passive: false });

function spawnEnemy() {
    if (Math.random() < 0.03) {
        enemiesList.push({
            x: Math.random() * gameW, y: -50,
            size: 15 + Math.random() * 20,
            speed: 2 + Math.random() * 3,
            color: '#f43f5e'
        });
    }
}

function animate() {
    if (!gameRunning) return;
    ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, gameW, gameH);

    // Smooth movement logic
    playerObj.x += (playerObj.targetX - playerObj.x) * 0.3;
    if (playerObj.x < 20) playerObj.x = 20;
    if (playerObj.x > gameW - 20) playerObj.x = gameW - 20;

    // Draw Player
    ctx.shadowBlur = 15; ctx.shadowColor = '#0ff';
    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(playerObj.x, playerObj.y - 15);
    ctx.lineTo(playerObj.x + 15, playerObj.y + 15);
    ctx.lineTo(playerObj.x - 15, playerObj.y + 15);
    ctx.closePath(); ctx.stroke();
    ctx.shadowBlur = 0;

    // Auto-fire logic
    if (Date.now() % 150 < 20) {
        bulletsList.push({ x: playerObj.x, y: playerObj.y - 15 });
        AudioSys.playShoot();
    }

    // Update bullets
    bulletsList.forEach((b, i) => {
        b.y -= 10;
        ctx.fillStyle = '#ff0';
        ctx.fillRect(b.x - 2, b.y, 4, 10);
        if (b.y < 0) bulletsList.splice(i, 1);
    });

    // Update enemies
    spawnEnemy();
    enemiesList.forEach((e, i) => {
        e.y += e.speed;
        ctx.strokeStyle = e.color;
        ctx.strokeRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);

        // Bullet collisions
        bulletsList.forEach((b, bi) => {
            if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                enemiesList.splice(i, 1);
                bulletsList.splice(bi, 1);
                gameScore += 100;
                AudioSys.playExplosion();
            }
        });

        // Player collisions
        if (Math.hypot(playerObj.x - e.x, playerObj.y - e.y) < e.size + 15) {
            enemiesList.splice(i, 1);
            playerObj.shield -= 20;
            AudioSys.playExplosion();
            if (playerObj.shield <= 0) endGame();
        }

        if (e.y > gameH + 50) enemiesList.splice(i, 1);
    });

    document.getElementById('scoreEl').innerText = gameScore;
    document.getElementById('shieldEl').innerText = playerObj.shield + '%';
    requestAnimationFrame(animate);
}

function startGame() {
    AudioSys.init();
    gameScore = 0;
    enemiesList = []; bulletsList = [];
    initPlayer();
    gameRunning = true;
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    animate();
}

function endGame() {
    gameRunning = false;
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = gameScore;
}

document.getElementById('startBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    startGame();
});
document.getElementById('restartBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    startGame();
});
</script>
</body>
</html>
